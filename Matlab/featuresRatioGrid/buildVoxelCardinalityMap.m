paddedMinX = areaOfInterest.distFromRobot + areaOfInterest.xTfAdjustment...
    - nbOfPaddingVoxel*voxelSide;
paddedMaxX = paddedMinX + areaOfInterest.depth + ...
    2*nbOfPaddingVoxel*voxelSide;
paddedMinY = -areaOfInterest.width/2 - nbOfPaddingVoxel*voxelSide;
paddedMaxY = areaOfInterest.width/2 + nbOfPaddingVoxel*voxelSide;

tic

for sampleIndex = 1:nbOfSamples;
    groundHeight = dataset(sampleIndex).groundHeight;
    paddedMinZ = groundHeight - nbOfPaddingVoxel*voxelSide;
    paddedMaxZ = paddedMinZ + areaOfInterest.height + ...
        2*nbOfPaddingVoxel*voxelSide;
    
    pointCloud = dataset(sampleIndex).rawPointCloud;
    pointCloud = pointCloud(find(...
        pointCloud(:,1) >= paddedMinX & ...
        pointCloud(:,1) < paddedMaxX & ...
        pointCloud(:,2) >= paddedMinY & ...
        pointCloud(:,2) < paddedMaxY & ...
        pointCloud(:,3) >= paddedMinZ & ...
        pointCloud(:,3) < paddedMaxZ),:);
    
    voxelCardinalityMap = zeros(nbOfX, nbOfY, nbOfZ);
    for i = 1:nbOfX
        minX = paddedMinX + (i-1)*voxelSide;
        maxX = paddedMinX + i*voxelSide;
        for j = 1:nbOfY
            minY = paddedMinY + (j-1)*voxelSide;
            maxY = paddedMinY + j*voxelSide;
            for k = 1:nbOfZ
                minZ = paddedMinZ + (k-1)*voxelSide;
                maxZ = paddedMinZ + k*voxelSide;
                
                voxelCardinalityMap(i,j,k) = length(find(...
                    pointCloud(:,1) >= minX & ...
                    pointCloud(:,1) < maxX & ...
                    pointCloud(:,2) >= minY & ...
                    pointCloud(:,2) < maxY & ...
                    pointCloud(:,3) >= minZ & ...
                    pointCloud(:,3) < maxZ));
            end
        end
    end
    dataset(sampleIndex).voxelCardinalityMap = voxelCardinalityMap;
end

buildVoxelCardinalityMapTime = toc